* Package testing
  * provides
    * support -- for -- Go packages' automated testing

* `go test`
  * run tests

* ðŸ’¡steps to create a testðŸ’¡
  * create a file / 
    * 's naming's end "_test.go"
    * contains the "TestXxx" functions 
      ```go
      func TestXxx(*testing.T)
      // Xxx      ==      NOT start -- with a -- lowercase letter 
      ```
      * Reason: ðŸ§ function name identifies the test routineðŸ§ 
      * 's methods / signal failure
        * `Error`
        * `Fail`
    * âš ï¸excluded -- from -- regular package buildsâš ï¸
    * 's locationS (about package) recommended 
      * == no test file 's location (== package), OR
        * enable
          * ðŸ‘€refer -- to -- package's unexported identifiersðŸ‘€ 
        * _Example:_ [here](examples/abs_test.go)
      * corresponding package / 's suffix == "_test"
        * _Example:_ [here](examples/abs_otherpackage_test.go)

* `go help test` OR `go help testflag`

# Benchmarks

* := functionS / 
  * file's
    * naming's end "_test.go"
    * contains the function
      ```go
      func BenchmarkXxx(*testing.B)    
      ```
  * run
    * by default, sequentially
    * if you want to run parallel -> use the `.RunParallel()` helper function + `go test -cpu`

* ðŸ‘€ways to executeðŸ‘€
  * `go test -bench=.`
    * run ALL benchmarks
  * `go test -bench=BenchmarkConcreteName`
    * run the benchmark "BenchmarkConcreteName"
  * see [here](https://golang.org/cmd/go/#hdr-Testing_flags)

* 's output
  * number of times / loop ran
  * speed / loop
  
  ```
  BenchmarkRandInt-8   	68453040	        17.8 ns/op
  ```
  * see [here](https://golang.org/design/14313-benchmark-format)
  
* if benchmark needs some expensive setup BEFORE running -> timer may be reset

* [tools / work with benchmark results](https://golang.org/x/perf/cmd) 
  * [benchstat](https://golang.org/x/perf/cmd/benchstat)
    * performs robust A/B comparisons

# Example functions

* := test functions / 
  * enabled for
    * package
      ```go
      func Example() { ... }
      ```
    * public function
      ```go
      func ExampleFunctionName() { ... }
      ```
      * âŒif function != public -> NOT possible testingâŒ 
      * if you want to provide >1 examples -> add the suffix "_anotherThing"
        ```go
        func ExampleFunctionName_anotherThing() { ... }
        ```
    * type
      ```go
      func ExampleTypeName() { ... }
      ```
    * type's method
      ```go
      func ExampleTypeName_MethodName() { ... }
      ```

* requirements
  * 's body
    * âš ï¸`fmt.Println`âš ï¸
    * concluding line comments /
      * âš ï¸begins with
        * "Output:"âš ï¸
        * "Unordered output:" == "Output:" / matches ANY line order
      * ignores leading & trailing space
      * OTHERWISE -> 
        * compiled
        * NOT executed 

* `go test -v`
  * run it

# Fuzzing

* TODO:
'go test' and the testing package support fuzzing, a testing technique where
// a function is called with randomly generated inputs to find bugs not
// anticipated by unit tests.
//
// Functions of the form
//
//	func FuzzXxx(*testing.F)
//
// are considered fuzz tests.
//
// For example:
//
//	func FuzzHex(f *testing.F) {
//	  for _, seed := range [][]byte{{}, {0}, {9}, {0xa}, {0xf}, {1, 2, 3, 4}} {
//	    f.Add(seed)
//	  }
//	  f.Fuzz(func(t *testing.T, in []byte) {
//	    enc := hex.EncodeToString(in)
//	    out, err := hex.DecodeString(enc)
//	    if err != nil {
//	      t.Fatalf("%v: decode: %v", in, err)
//	    }
//	    if !bytes.Equal(in, out) {
//	      t.Fatalf("%v: not equal after round trip: %v", in, out)
//	    }
//	  })
//	}
//
// A fuzz test maintains a seed corpus, or a set of inputs which are run by
// default, and can seed input generation. Seed inputs may be registered by
// calling (*F).Add or by storing files in the directory testdata/fuzz/<Name>
// (where <Name> is the name of the fuzz test) within the package containing
// the fuzz test. Seed inputs are optional, but the fuzzing engine may find
// bugs more efficiently when provided with a set of small seed inputs with good
// code coverage. These seed inputs can also serve as regression tests for bugs
// identified through fuzzing.
//
// The function passed to (*F).Fuzz within the fuzz test is considered the fuzz
// target. A fuzz target must accept a *T parameter, followed by one or more
// parameters for random inputs. The types of arguments passed to (*F).Add must
// be identical to the types of these parameters. The fuzz target may signal
// that it's found a problem the same way tests do: by calling T.Fail (or any
// method that calls it like T.Error or T.Fatal) or by panicking.
//
// When fuzzing is enabled (by setting the -fuzz flag to a regular expression
// that matches a specific fuzz test), the fuzz target is called with arguments
// generated by repeatedly making random changes to the seed inputs. On
// supported platforms, 'go test' compiles the test executable with fuzzing
// coverage instrumentation. The fuzzing engine uses that instrumentation to
// find and cache inputs that expand coverage, increasing the likelihood of
// finding bugs. If the fuzz target fails for a given input, the fuzzing engine
// writes the inputs that caused the failure to a file in the directory
// testdata/fuzz/<Name> within the package directory. This file later serves as
// a seed input. If the file can't be written at that location (for example,
// because the directory is read-only), the fuzzing engine writes the file to
// the fuzz cache directory within the build cache instead.
//
// When fuzzing is disabled, the fuzz target is called with the seed inputs
// registered with F.Add and seed inputs from testdata/fuzz/<Name>. In this
// mode, the fuzz test acts much like a regular test, with subtests started
// with F.Fuzz instead of T.Run.
* [MORE](https://go.dev/doc/fuzz) 
